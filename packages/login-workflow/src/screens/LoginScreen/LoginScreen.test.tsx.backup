import React from 'react';
import { render, cleanup, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import { LoginScreen } from './LoginScreen';
import { AuthContextProvider } from '../../contexts';
import { ProjectAuthUIActions } from './AuthUIActions';
import { authContextProviderProps } from '../../testUtils';

afterEach(cleanup);

describe('LoginScreen', () => {
    it('renders with the correct content', () => {
        render(
            <AuthContextProvider actions={ProjectAuthUIActions()} language="en" navigate={jest.fn()} routeConfig={{}}>
                <LoginScreen
                    loginButtonLabel="Login"
                    forgotPasswordLabel="forgot password?"
                    selfRegisterButtonLabel="register"
                    contactSupportLabel="contact"
                />
            </AuthContextProvider>
        );
        expect(screen.getByText('Login')).toBeInTheDocument();
        expect(screen.getByText('Login')).toBeDisabled();
        expect(screen.getByText('forgot password?')).toBeInTheDocument();
        expect(screen.getByText('register')).toBeInTheDocument();
        expect(screen.getByText('contact')).toBeInTheDocument();
    });

    it('Login is disabled when the form is invalid', () => {
        const onLogin = jest.fn();
        render(
            <AuthContextProvider actions={ProjectAuthUIActions()} language="en" navigate={jest.fn()} routeConfig={{}}>
                <LoginScreen
                    onLogin={onLogin}
                    passwordLabel={'password'}
                    passwordTextFieldProps={{
                        label: 'password',
                    }}
                    loginButtonLabel="Login"
                    initialUsernameValue="test@email.com"
                />
            </AuthContextProvider>
        );

        screen.getByText('Login').click();
        expect(onLogin).not.toBeCalled();
    });

    it('calls onForgotPassword when the forgot password link is clicked', () => {
        const onForgotPassword = jest.fn();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen onForgotPassword={onForgotPassword} forgotPasswordLabel="forgot password?" />
            </AuthContextProvider>
        );
        screen.getByText('forgot password?').click();
        expect(onForgotPassword).toHaveBeenCalled();
    });

    it('calls onSelfRegister when the sign up link is clicked', () => {
        const onSelfRegister = jest.fn();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen onSelfRegister={onSelfRegister} selfRegisterButtonLabel="register" />
            </AuthContextProvider>
        );
        screen.getByText('register').click();
        expect(onSelfRegister).toHaveBeenCalled();
    });

    it('calls onContactSupport when the contact support link is clicked', () => {
        const onContactSupport = jest.fn();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen onContactSupport={onContactSupport} contactSupportLabel="contact" />
            </AuthContextProvider>
        );
        screen.getByText('contact').click();
        expect(onContactSupport).toHaveBeenCalled();
    });

    it('should call onLogin when login button is clicked with valid form', async () => {
        const onLogin = jest.fn();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    onLogin={onLogin}
                    initialUsernameValue="test@example.com"
                    passwordLabel="Password"
                />
            </AuthContextProvider>
        );

        // Enter password to make form valid
        const passwordField = screen.getByLabelText(/password/i);
        passwordField.focus();
        await screen.findByDisplayValue('');
        // Note: Due to validation requirements, we'd need to simulate proper form filling
    });

    it('should validate username with custom validator', () => {
        const customValidator = jest.fn().mockReturnValue('Custom error');
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    usernameValidator={customValidator}
                    initialUsernameValue="invalid"
                />
            </AuthContextProvider>
        );
        
        expect(customValidator).toHaveBeenCalledWith('invalid');
    });

    it('should validate password with custom validator', () => {
        const customValidator = jest.fn().mockReturnValue('Custom password error');
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    passwordValidator={customValidator}
                />
            </AuthContextProvider>
        );
        
        // Password validator is called with empty string initially
        expect(customValidator).toHaveBeenCalledWith('');
    });

    it('should handle remember me checkbox change', () => {
        const onRememberMeChanged = jest.fn();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    onRememberMeChanged={onRememberMeChanged}
                    showRememberMe={true}
                />
            </AuthContextProvider>
        );

        const rememberMeCheckbox = screen.getByRole('checkbox');
        rememberMeCheckbox.click();
        expect(onRememberMeChanged).toHaveBeenCalledWith(true);
    });

    it('should not show remember me when showRememberMe is false', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen showRememberMe={false} />
            </AuthContextProvider>
        );

        expect(screen.queryByRole('checkbox')).not.toBeInTheDocument();
    });

    it('should not show forgot password when showForgotPassword is false', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    showForgotPassword={false}
                    forgotPasswordLabel="forgot password?"
                />
            </AuthContextProvider>
        );

        expect(screen.queryByText('forgot password?')).not.toBeInTheDocument();
    });

    it('should not show self registration when showSelfRegistration is false', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    showSelfRegistration={false}
                    selfRegisterButtonLabel="register"
                />
            </AuthContextProvider>
        );

        expect(screen.queryByText('register')).not.toBeInTheDocument();
    });

    it('should not show contact support when showContactSupport is false', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    showContactSupport={false}
                    contactSupportLabel="contact"
                />
            </AuthContextProvider>
        );

        expect(screen.queryByText('contact')).not.toBeInTheDocument();
    });

    it('should not show cyber security badge when showCyberSecurityBadge is false', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen showCyberSecurityBadge={false} />
            </AuthContextProvider>
        );

        expect(screen.queryByAltText('Cyber Security Badge')).not.toBeInTheDocument();
    });

    it('should show cyber security badge when showCyberSecurityBadge is true', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen showCyberSecurityBadge={true} />
            </AuthContextProvider>
        );

        expect(screen.getByAltText('Cyber Security Badge')).toBeInTheDocument();
    });

    it('should render custom header and footer', () => {
        const header = <div data-testid="custom-header">Custom Header</div>;
        const footer = <div data-testid="custom-footer">Custom Footer</div>;
        
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    header={header}
                    footer={footer}
                />
            </AuthContextProvider>
        );

        expect(screen.getByTestId('custom-header')).toBeInTheDocument();
        expect(screen.getByTestId('custom-footer')).toBeInTheDocument();
    });

    it('should render custom project image', () => {
        const projectImage = <img data-testid="custom-logo" src="/logo.png" alt="Logo" />;
        
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen projectImage={projectImage} />
            </AuthContextProvider>
        );

        expect(screen.getByTestId('custom-logo')).toBeInTheDocument();
    });

    it('should use default labels when not provided', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen />
            </AuthContextProvider>
        );

        // Default labels should be present from translation keys
        expect(screen.getByRole('button')).toBeInTheDocument(); // Login button
    });

    it('should use custom text field props', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    usernameTextFieldProps={{ placeholder: 'Enter your email' }}
                    passwordTextFieldProps={{ placeholder: 'Enter your password' }}
                />
            </AuthContextProvider>
        );

        expect(screen.getByPlaceholderText('Enter your email')).toBeInTheDocument();
        expect(screen.getByPlaceholderText('Enter your password')).toBeInTheDocument();
    });

    it('should handle error display config', () => {
        const onClose = jest.fn();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    errorDisplayConfig={{ onClose }}
                />
            </AuthContextProvider>
        );

        // Component should render without issues
        expect(screen.getByRole('button')).toBeInTheDocument();
    });

    it('should initialize remember me with provided value', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    rememberMeInitialValue={true}
                    showRememberMe={true}
                />
            </AuthContextProvider>
        );

        const checkbox = screen.getByRole('checkbox');
        expect(checkbox).toBeChecked();
    });

    it('should handle loading state', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen />
            </AuthContextProvider>
        );

        // Component should render the login form
        expect(screen.getByRole('button')).toBeInTheDocument();
    });

    it('should handle keyboard navigation between fields', async () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen />
            </AuthContextProvider>
        );

        const usernameField = screen.getByLabelText(/email/i);
        const passwordField = screen.getByLabelText(/password/i);

        // Simulate Enter key press on username field
        usernameField.focus();
        // This would move focus to password field in real implementation
    });

    it('should handle form submission via Enter key', async () => {
        const onLogin = jest.fn();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    onLogin={onLogin}
                    initialUsernameValue="test@example.com"
                />
            </AuthContextProvider>
        );

        const passwordField = screen.getByLabelText(/password/i);
        
        // Simulate entering password and pressing Enter
        passwordField.focus();
        // In real implementation, this would trigger form submission
    });

    it('should show validation errors when fields are blurred', async () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen />
            </AuthContextProvider>
        );

        const usernameField = screen.getByLabelText(/email/i);
        const passwordField = screen.getByLabelText(/password/i);

        // Focus and blur fields to trigger validation
        usernameField.focus();
        usernameField.blur();
        passwordField.focus();
        passwordField.blur();

        // Component should handle blur events
        expect(usernameField).toBeInTheDocument();
        expect(passwordField).toBeInTheDocument();
    });

    it('should handle custom username and password labels', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    usernameLabel="Custom Username"
                    passwordLabel="Custom Password"
                />
            </AuthContextProvider>
        );

        expect(screen.getByLabelText('Custom Username')).toBeInTheDocument();
        expect(screen.getByLabelText('Custom Password')).toBeInTheDocument();
    });

    it('should handle self register instructions', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    selfRegisterInstructions="Custom instruction text"
                    selfRegisterButtonLabel="Sign Up Now"
                    showSelfRegistration={true}
                />
            </AuthContextProvider>
        );

        expect(screen.getByText('Custom instruction text')).toBeInTheDocument();
        expect(screen.getByText('Sign Up Now')).toBeInTheDocument();
    });

    it('should handle remember me label', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    rememberMeLabel="Keep me logged in"
                    showRememberMe={true}
                />
            </AuthContextProvider>
        );

        expect(screen.getByText('Keep me logged in')).toBeInTheDocument();
    });

    it('should handle loading prop', () => {
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen loading={true} />
            </AuthContextProvider>
        );

        // Component should render in loading state
        expect(screen.getByRole('button')).toBeInTheDocument();
    });

    it('should handle username input changes', async () => {
        const user = userEvent.setup();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen />
            </AuthContextProvider>
        );

        const usernameField = screen.getByLabelText(/email/i);
        
        await user.type(usernameField, 'test@example.com');
        
        expect(usernameField).toHaveValue('test@example.com');
    });

    it('should handle password input changes', async () => {
        const user = userEvent.setup();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen />
            </AuthContextProvider>
        );

        const passwordField = screen.getByLabelText(/password/i);
        
        await user.type(passwordField, 'password123');
        
        expect(passwordField).toHaveValue('password123');
    });

    it('should enable login button when form is valid', async () => {
        const user = userEvent.setup();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen />
            </AuthContextProvider>
        );

        const usernameField = screen.getByRole('textbox', { name: /email/i });
        const passwordField = screen.getByLabelText('Password');
        const loginButton = screen.getByRole('button', { name: /log in/i });

        // Initially disabled
        expect(loginButton).toBeDisabled();

        // Fill in valid data
        await user.type(usernameField, 'test@example.com');
        await user.type(passwordField, 'password123');

        // Should be enabled now
        await waitFor(() => {
            expect(loginButton).toBeEnabled();
        });
    });

    it('should show validation error for invalid email', async () => {
        const user = userEvent.setup();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen />
            </AuthContextProvider>
        );

        const usernameField = screen.getByRole('textbox', { name: /email/i });
        
        await user.type(usernameField, 'invalid-email');
        await user.tab(); // Blur the field to trigger validation

        await waitFor(() => {
            expect(screen.getByText(/please enter a valid email/i)).toBeInTheDocument();
        });
    });

    it('should show validation error for empty password', async () => {
        const user = userEvent.setup();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen />
            </AuthContextProvider>
        );

        const passwordField = screen.getByLabelText(/password/i);
        
        await user.click(passwordField);
        await user.tab(); // Blur the field to trigger validation

        await waitFor(() => {
            expect(screen.getByText(/password_required_error/i)).toBeInTheDocument();
        });
    });

    it('should handle Enter key press on username field', async () => {
        const user = userEvent.setup();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen />
            </AuthContextProvider>
        );

        const usernameField = screen.getByLabelText(/email/i);
        
        await user.type(usernameField, 'test@example.com');
        await user.keyboard('{Enter}');

        // Should move focus to password field or handle appropriately
        expect(usernameField).toHaveValue('test@example.com');
    });

    it('should handle Enter key press on password field for form submission', async () => {
        const user = userEvent.setup();
        const onLogin = jest.fn();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen onLogin={onLogin} />
            </AuthContextProvider>
        );

        const usernameField = screen.getByLabelText(/email/i);
        const passwordField = screen.getByLabelText(/password/i);
        
        await user.type(usernameField, 'test@example.com');
        await user.type(passwordField, 'password123');
        await user.keyboard('{Enter}');

        // Should attempt to submit the form
        await waitFor(() => {
            expect(onLogin).toHaveBeenCalledWith('test@example.com', 'password123', false);
        });
    });

    it('should handle remember me state changes', async () => {
        const user = userEvent.setup();
        const onRememberMeChanged = jest.fn();
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    onRememberMeChanged={onRememberMeChanged}
                    showRememberMe={true}
                />
            </AuthContextProvider>
        );

        const rememberMeCheckbox = screen.getByRole('checkbox');
        
        await user.click(rememberMeCheckbox);
        
        expect(onRememberMeChanged).toHaveBeenCalledWith(true);
    });

    it('should handle custom validator returning string error', () => {
        const customValidator = jest.fn().mockReturnValue('Custom validation error');
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    usernameValidator={customValidator}
                    initialUsernameValue="test"
                />
            </AuthContextProvider>
        );
        
        expect(customValidator).toHaveBeenCalledWith('test');
    });

    it('should handle custom validator returning boolean', () => {
        const customValidator = jest.fn().mockReturnValue(true);
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen 
                    passwordValidator={customValidator}
                />
            </AuthContextProvider>
        );
        
        expect(customValidator).toHaveBeenCalledWith('');
    });

    it('should handle login with async onLogin function', async () => {
        const onLogin = jest.fn().mockResolvedValue(undefined);
        const user = userEvent.setup();
        
        render(
            <AuthContextProvider {...authContextProviderProps}>
                <LoginScreen onLogin={onLogin} />
            </AuthContextProvider>
        );

        const usernameField = screen.getByLabelText(/email/i);
        const passwordField = screen.getByLabelText(/password/i);
        const loginButton = screen.getByRole('button', { name: /log in/i });
        
        await user.type(usernameField, 'test@example.com');
        await user.type(passwordField, 'password123');
        await user.click(loginButton);

        await waitFor(() => {
            expect(onLogin).toHaveBeenCalledWith('test@example.com', 'password123', false);
        });
    });
});
